---
description: Оптимизация выполнения кода: orjson, xxhash, циклы, подготовка к mypyc/C++
globs: **/*.py
alwaysApply: false
---

# Performance optimization (Python)

## 1. JSON — только orjson

- Везде использовать **orjson** для сериализации/десериализации JSON. Не использовать `json` из stdlib в core path.
- Для детерминированного вывода: `orjson.dumps(obj, option=orjson.OPT_SORT_KEYS)`.
- `orjson.dumps` возвращает `bytes`; для строки при необходимости: `.decode("utf-8")`.
- Парсинг: `orjson.loads(bytes_or_str)`.

```python
# ❌ BAD
import json
s = json.dumps(data, sort_keys=True)

# ✅ GOOD
import orjson
blob = orjson.dumps(data, option=orjson.OPT_SORT_KEYS)
```

## 2. Хеширование — только xxhash

- Для любых хешей (идентичность, подписи, кеш-ключи) использовать **xxhash**.
- Предпочтительно `xxhash.xxh3_128` для 128-bit (например, `.hexdigest()`). Для 64-bit: `xxhash.xxh64`.
- Для детерминированного хеша от структуры: сериализовать через orjson (OPT_SORT_KEYS), затем хешировать bytes.

```python
# ❌ BAD
import hashlib
h = hashlib.sha256(data).hexdigest()

# ✅ GOOD
import xxhash
h = xxhash.xxh3_128(data, seed=0).hexdigest()
# или для пары 128-bit: xxh3_128(blob, seed=0).hexdigest() + xxh3_128(blob, seed=1).hexdigest()
```

## 3. Циклы и массивы

- Предпочитать **векторизованные операции** (NumPy) вместо Python-циклов по числовым массивам, если это не ломает детерминизм и зависимости уже есть.
- В циклах: выносить инварианты (константы, повторные lookup) за цикл; избегать повторного создания списков/словарей внутри цикла.
- Где цикл неизбежен: предпочитать `list`/tuple с заранее известным размером; по возможности использовать comprehensions вместо ручных append.
- Не вызывать в цикле тяжёлые операции (например, сериализацию orjson) без необходимости — кешировать или агрегировать.

```python
# ❌ BAD: lookup и создание списка в каждой итерации
for i in range(n):
    key = some_dict["expensive_key"]
    result.append(transform(items[i], key))

# ✅ GOOD: инвариант снаружи, предвыделение при возможности
key = some_dict["expensive_key"]
result = [transform(items[i], key) for i in range(n)]
```

## 4. Подготовка к mypyc и будущему C++

Цель: код core computation готов к компиляции (mypyc → C extension или вынос в C++) для ускорения подсчётов. mypyc даёт существенный прирост на типизированном коде без смены синтаксиса.

### 4.1 Типизация — обязательна в hot path

- Все функции и переменные в модулях вычислений (modulation, assembler, boundaries, identity, state) должны иметь **полные type hints** (аргументы и возвращаемый тип).
- Использовать конкретные типы: `tuple[float, ...]`, `list[float]`, `tuple[int, int]` вместо `Any` или неаннотированных коллекций. Для фиксированных размеров (32, 8) — типы вроде `tuple[float, ...]` с проверкой длины в рантайме или TypedDict/константы.
- Это нужно и для mypy, и для mypyc: без аннотаций mypyc не даёт прироста.

```python
# ❌ BAD: нет аннотаций — mypyc не оптимизирует
def aggregate_axis(params):
    return [sum(params[i:i+4])/4 for i in range(0, 32, 4)]

# ✅ GOOD: полные аннотации — кандидат для mypyc/C++
def aggregate_axis(params: tuple[float, ...]) -> tuple[float, ...]:
    return tuple(sum(params[i:i+4]) / 4.0 for i in range(0, 32, 4))
```

### 4.2 Граница «core computation»

- Выделять **чистые функции вычислений** (вход: числа/кортежи, выход: числа/кортежи) без I/O, без логов внутри цикла, без обращения к глобальному состоянию в цикле. Именно их выносить в mypyc или в C++ в первую очередь.
- Не смешивать в одной функции: тяжёлые числовые циклы и orjson/файлы/сеть. I/O — снаружи, вычисления — в отдельном слое с чёткими типами.

### 4.3 Удобный для C/C++ layout данных

- В горячем коде предпочитать **фиксированные размеры** (32 параметра, 8 осей): `tuple[float, ...]` или списки фиксированной длины, без динамического роста в цикле.
- Избегать в hot path: `dict` в цикле (по возможности — индекс или tuple), `getattr`/`setattr`, динамическое добавление атрибутов. Это усложняет и mypyc, и будущий порт на C++.
- Числовые константы (размеры, индексы) — в константах модуля (например `NUM_PARAMETERS = 32`), чтобы при порте на C++ они стали константами или `constexpr`.

### 4.4 Что даёт выигрыш при компиляции

- **mypyc**: компилирует типизированный Python в C extension; типичный прирост 1.5×–10× на «правильном» коде; не требует своего синтаксиса, только аннотации и соблюдение ограничений (см. mypyc docs).
- **Будущий C++**: те же модули (modulation, boundaries, assembler, хеш от структур) — кандидаты на вынос в C++ extension (pybind11/cffi); единый контракт: bytes in/out для orjson, фиксированные массивы float для параметров/осей.
